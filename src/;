extern crate rand;
use rand::{thread_rng,Rng};
use std::{ptr,fmt};

const MAX_FLOAT:f32=9999999999999999999999999.0;



#[derive(Debug,Copy,Clone)]
pub struct Vec3D<T> {
    pub x:T,
    pub y:T,
    pub z:T,
}

type v3f=Vec3D<f32>;
type v3i=Vec3D<i32>;



pub struct HitRecord<'a,'m:'a>{
    pub t:f32,
    pub p:v3f,
    pub normal:v3f,
    pub mat:Option<& 'a Box<Material<'m > >>
}

impl <'a,'m:'a> HitRecord<'m,'a>{
    pub fn new()->Self{
        HitRecord{
            t:0.0,
            p:v3f{x:0.0,y:0.0,z:0.0},
            normal:v3f{x:0.0,y:0.0,z:0.0},
            mat:None
        }
    }
}

pub trait Hitable<'a,'m:'a>{
    fn Hit<'r1,'s:'r1+'m>(& 's self,r:Ray,t_min:f32,t_max:f32,rec:& 'r1 mut  HitRecord<'a,'m>)
        ->Option<& 'r1 mut HitRecord<'a,'m>>;
}

impl Vec3D<f32>{
    pub fn Length(&self)-> f32{
        let mut value:f32=self.x*self.x+self.y*self.y+self.z*self.z;
        value.sqrt()
    }
    
    pub fn SquaredLength(&self)-> f32{
        let mut value:f32=self.x*self.x+self.y*self.y+self.z*self.z;
        value
    }

    pub fn ToI32(&self)->Vec3D<i32>{
        Vec3D{x:self.x as i32,y:self.y as i32,z:self.z as i32}
    }
}

#[derive(Debug,Copy,Clone)]
pub struct Ray{
    pub origin:v3f,
    pub direction:v3f,
}

impl Ray{
    pub fn new()->Self{
        Ray{
            origin:v3f{x:0.0,y:0.0,z:0.0},
            direction:v3f{x:0.0,y:0.0,z:0.0},            
        }
    }

    pub fn PointAtParameter(&self,t:f32) -> v3f{
        let v=VecMul3D(&self.direction,t);
        let r=VecAdd3D(&self.origin,&v);
        r
    }
}


pub fn VecDot3D(v1:&Vec3D<f32>,v2:&Vec3D<f32>)-> f32{
    (v1.x*v2.x+v1.y*v2.y+v1.z*v2.z)
}

pub fn VecCross3D(v1:&Vec3D<f32>,v2:&Vec3D<f32>)-> Vec3D<f32>{
    let x=v1.y*v2.z-v1.z*v2.y;
    let y=-(v1.x*v2.z)-v1.z*v2.x;
    let z=v1.x*v2.y-v1.y*v2.x;

    Vec3D{x:x,y:y,z:z}
}

pub fn VecAdd3D(v1:&Vec3D<f32>,v2:&Vec3D<f32>)-> Vec3D<f32>{
   Vec3D{x:v1.x+v2.x,y:v1.y+v2.y,z:v1.z+v2.z}
}

pub fn VecSub3D(v1:&Vec3D<f32>,v2:&Vec3D<f32>)-> Vec3D<f32>{
    Vec3D{x:v1.x-v2.x,y:v1.y-v2.y,z:v1.z-v2.z}
}

pub fn VecMul3D(v:&Vec3D<f32>,f:f32)->Vec3D<f32>{
    Vec3D{x:v.x*f,y:v.y*f,z:v.z*f}
}


pub fn VecDiv3D(v:&v3f,f:f32)->v3f{
    Vec3D{x:v.x/f,y:v.y/f,z:v.z/f}
}

pub fn VecNorm3D(v:&v3f)->v3f{
    let length=v.Length();
    VecDiv3D(v,length)
}

pub fn Refrect(v:&v3f,n:&v3f)->v3f{
    let result=VecDot3D(&v,&n)*2.0;
    let nn=VecMul3D(&n,result);
    VecSub3D(&v,&nn)
}

//#[derive(Debug,Copy,Clone)]
pub struct Sphere<'m > {
    pub center:v3f,
    pub radius:f32,
    pub  material: Box<Material<'m  > >,
}

impl  <'a,'m:'a> Hitable<'a,'m> for Sphere< 'm > {

    fn Hit<'r1,'s:'r1+'m>(& 's self,r:Ray,t_min:f32,t_max:f32,rec:& 'r1 mut HitRecord<'a,'m>)
    ->Option<& 'r1 mut HitRecord<'a,'m>>{

        
        /*let oc=VecSub3D(&r.origin,&self.center);
        let a=VecDot3D(&r.direction,&r.direction);
        let b=VecDot3D(&oc,&r.direction);
        let c=VecDot3D(&oc,&oc)-(self.radius*self.radius);
        let discriminant=(b*b)-(a*c);
        
        if discriminant>0.0 {
            let sq:f32=(b*b)-(a*c);
            let mut temp:f32=(-b-sq.sqrt())/a;
            
            if temp <t_max && temp>t_min{
                rec.t=temp;
                rec.p=r.PointAtParameter(rec.t);
                rec.normal=VecSub3D(&rec.p,&self.center);
                rec.normal=VecDiv3D(&rec.normal,self.radius);
                rec.mat=Some(&self.material);
                return Some(rec);
            }
            
            temp=(-b+sq.sqrt())/a;
            if temp<t_max && temp>t_min{
                rec.t=temp;
                rec.p=r.PointAtParameter(rec.t);
                rec.normal=VecSub3D(&rec.p,&self.center);
                rec.normal=VecDiv3D(&rec.normal,self.radius);
                return Some(rec);
            }
        }*/
        None
    }

}


    //r lifetime for rec must be smaler than a and m
    pub fn GetColor<'rh,'r:'rh,'a:'r,'m:'a>(mut ray:Ray,world:& World<'a,'m>,rec:& 'rh mut HitRecord<'a,'m>)->v3f{
    
        let b:bool;
        
        let mut tmp_rec=HitRecord::new();        
        let result=world.Hit(ray,0.001,MAX_FLOAT,& mut tmp_rec);

        if let Some(hit_rec)=result {
            let scattered=Ray::new();
            
            let random=RandomInUnitSphere();
            let mut target=VecAdd3D(&hit_rec.p,&hit_rec.normal);
            target=VecAdd3D(&target,&random);
            
            let mut v=GetColor(
                    Ray{
                    origin:rec.p,
                    direction:VecSub3D(&target,&hit_rec.p)
            },
            world,hit_rec);

            v=VecMul3D(&v,0.5);
            return v; 
        }else{
            let mut unit_direction=VecNorm3D(&ray.direction);
            let t=0.5*(unit_direction.y+1.0);
            let v1=v3f{x:(1.0-t),y:(1.0-t),z:(1.0-t)};
            let v2=v3f{x:0.5*t,y:0.7*t,z:1.0*t};

            return VecAdd3D(&v1,&v2);
        }
        
        //v3f{x:0.0,y:0.0,z:0.0}
    }

pub fn HitSphere(center:v3f,radius:f32,r:Ray)->f32 {
    let oc=VecSub3D(&r.origin,&center);
    let a=VecDot3D(&r.direction,&r.direction);
    let b=2.0*VecDot3D(&oc,&r.direction);
    let c=VecDot3D(&oc,&oc)-(radius*radius);
    let discriminant=b*b-(4.0*a*c);
    
    if discriminant<0.0{
        return -1.0;    
    }
    
    (-b-discriminant.sqrt())/(2.0*a)

}


pub struct World<'a,'m:'a>{
    pub  objects: Vec<Box<Hitable<'a,'m> > >,
}

impl <'a,'m:'a> World<'a,'m> {
    pub fn new()->Self {
        World{
            objects:Vec::new(),
        }
    }
}

impl <'a,'m:'a>  World<'a,'m>{

        fn Hit<'r1,'a1:'r1,'m1:'a1>(&self,r:Ray,t_min:f32,t_max:f32,rec:& 'r1 mut HitRecord<'a1,'m1>)
            ->Option<& 'r1  mut HitRecord<'a1,'m1>>{

            let mut hit_anything:bool=false;

            let mut temp_rec=HitRecord::new();

            let mut closest_so_far=t_max;
            let mut hit:bool=false;
            
            for obj in &self.objects {
                    let hit=obj.Hit(r,t_min,closest_so_far,&mut temp_rec);

                    if let Some(hit_rec)=hit{
                        hit_anything=true;
                        closest_so_far=hit_rec.t;
                        rec.t=hit_rec.t;
                        rec.p=hit_rec.p.clone();
                        rec.normal=hit_rec.normal.clone();
                    }
            }

            if hit_anything{
                return Some(rec);
            }else{
                return None;
            }

            //return None;
        }

}


pub struct Camera{
    pub lower_left_corner:v3f,
    pub horizontal:v3f,
    pub vertical:v3f,
    pub origin:v3f,
}

impl Camera{
    pub fn new()->Self{
        Camera{
            lower_left_corner:v3f{x:-2.0,y:-1.0,z:-1.0},
            horizontal:v3f{x:4.0,y:0.0,z:0.0},
            vertical:v3f{x:0.0,y:2.0,z:0.0},
            origin:v3f{x:0.0,y:0.0,z:0.0},

        }
    }

    pub fn GetRay(&self,u:f32,v:f32)->Ray{
            let mut v1=VecMul3D(&self.horizontal,u);            
            let v2=VecMul3D(&self.vertical,v);
            
            v1=VecAdd3D(&self.lower_left_corner,&v1);
            v1=VecAdd3D(&v1,&v2);

            let r:Ray=Ray{
                origin:self.origin,
                direction:v1
            };
            
            r
    }
}

pub fn RandomInUnitSphere()->v3f{
    let mut p=v3f{x:0.0,y:0.0,z:0.0};
    loop {
        let r1=thread_rng().gen_range(0.0,1.0);
        let r2=thread_rng().gen_range(0.0,1.0);
        let r3=thread_rng().gen_range(0.0,1.0);

        p=v3f{x:2.0*r1-1.0,y:2.0*r2-1.0,z:2.0*r3-1.0};
        if p.SquaredLength()<1.0 {  break; }
    }
    p
}
 
pub trait Material<'m>{
    fn Scatter(&self,r_in:Ray,rec:&HitRecord,attenuation:&mut v3f,scattered:&mut v3f)->bool;
}

pub struct Lambertian {
    pub albedo:v3f,
}

impl Lambertian{
    pub fn new(a:v3f)->Self{
        Lambertian{
            albedo:a
        }
    }

    pub fn TestRef(&self,v:&mut v3f){
        *v=self.albedo;

        println!("test1 :{:?}",v);
    }
}



impl  <'m> Material<'m> for Lambertian{
       fn Scatter(&self,r_in:Ray,rec:&HitRecord,attenuation:&mut v3f,scattered:&mut v3f)->bool{
        let random_point=RandomInUnitSphere();

        let mut target=VecAdd3D(&rec.p,&rec.normal);

        target=VecAdd3D(&target,&random_point);

        let scattered=Ray{
            origin:rec.p,
            direction:VecSub3D(&target,&rec.p)
        };

       *attenuation=self.albedo;

        return true
       }
}

pub struct Metal{
    pub albedo:v3f,
}

impl Metal{
    pub fn new(a:v3f)->Self{
        Metal{
            albedo:a
        }
    }
}

impl <'m> Material<'m> for Metal{
       fn Scatter(&self,r_in:Ray,rec:&HitRecord,attenuation:&mut v3f,scattered:&mut v3f)->bool{
           let unit_vector=VecNorm3D(&r_in.direction);

            let reflected=Reflect(&unit_vector,&rec.normal);
            let scattered=Ray{
                origin:rec.p,
                direction:reflected
            };

            *attenuation=self.albedo;
            let result=VecDot3D(&scattered.direction,&rec.normal);
            if result>0.0 {
                return true;
            }

            false
        }
}

pub fn Reflect(v:&v3f,n:&v3f)->v3f{
    let dot=2.0*VecDot3D(v,n);
    let t=VecMul3D(n,dot);
    VecSub3D(v,&t)
}






